# Set the path where the list will be saved
$outputFile = "$env:USERPROFILE\Desktop\dll_list.txt"

# Ensure any existing file is cleared out
if (Test-Path $outputFile) {
    Remove-Item $outputFile -Force
}

# Create a runspace pool
$runspacePool = [runspacefactory]::CreateRunspacePool(1, [Environment]::ProcessorCount)
$runspacePool.Open()

# Use an ArrayList instead of an array for mutability
$runspaces = New-Object System.Collections.ArrayList

# Create scriptblock for runspaces
$scriptBlock = {
    param($path)

    # Search for DLL files and return the results
    return (Get-ChildItem -Path $path -Recurse -Filter "*.dll" -ErrorAction SilentlyContinue).FullName
}

# Define the paths for each runspace, for this example, splitting the C: drive into main directories
$paths = Get-ChildItem -Path C:\ -Directory -ErrorAction SilentlyContinue | Select-Object -ExpandProperty FullName

foreach ($path in $paths) {
    $powershell = [powershell]::Create().AddScript($scriptBlock).AddArgument($path)
    $powershell.RunspacePool = $runspacePool

    [void]$runspaces.Add([PSCustomObject]@{
        PowerShell = $powershell
        Status = $powershell.BeginInvoke()
    })
}

# Gather results and write to the output file
foreach ($run in $runspaces) {
    $results = $run.PowerShell.EndInvoke($run.Status)
    foreach ($result in $results) {
        if ($result) {
            Add-Content -Path $outputFile -Value (Split-Path $result -Leaf)
        }
    }

}

# Close the runspace pool
$runspacePool.Close()
$runspacePool.Dispose()

# Notify user when the process is complete
Write-Host "DLL list saved to $outputFile"
